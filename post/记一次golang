---
title: "记一次golang"
date: 2018-12-25T17:50:01+08:00
draft: true
---

详情
昨天由于项目需要，加入发送短信功能，首先测试了一下已存在的一个Python代码，原理比较简单，向一个接口发送一个http post请求，请求的数据为xml格式，同时请求会带一个header头，Key为Host信息。

Python代码如下：

# coding=utf-8

import requests
import cgi

def send(phone, msg):
    url = 'http://xxx.com/MoblMsgSender'
    headers = {
        'Host': 'xxx.com',
    }
    body = '<?xml version="1.0" ?><S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/"><S:Header><AuthenticationHeader xmlns="http://xxx.com/MoblMsgSender"><Token>Tokenxxx==</Token></AuthenticationHeader></S:Header><S:Body><ns2:xxMmSender xmlns:ns2="http://xxx.com/"><arg0 xmlns="">%s</arg0><arg1 xmlns="">%s</arg1><arg2 xmlns="">yunwei.alarm</arg2><arg3 xmlns=""></arg3></ns2:xxMmSender></S:Body></S:Envelope>' % (phone, cgi.escape(msg))
    try:
        r = requests.post(url, data=body, headers=headers)
        if '<return>true</return>' in r.content:
            return True
    except:
        pass
    return False

send("135xxxxxxx","testPython")
果然成功收到了短信，证明接口调用成功。

于是我转化成golang代码：

package main

import (
    "bytes"
    "crypto/tls"
    "log"
    "net/http"
    "strings"
    "time"
)

func sendmessage(phone string, msg string) error {
    uri := `http://xxx.com/MoblMsgSender`
    //proxy, _ := url.Parse("http://127.0.0.1:8080")
    tr := &http.Transport{
        //Proxy:           http.ProxyURL(proxy),
        TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
    }
    client := &http.Client{
        Transport: tr,
        Timeout:   time.Second * 5, //超时时间
    }
    body := `<?xml version="1.0" encoding="UTF-8"?><S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/"><S:Header><AuthenticationHeader xmlns="http://mms.360buy.com/services/MoblMsgSender"><Token>666a8EN3oIijHY+KjS+2mg==</Token></AuthenticationHeader></S:Header><S:Body><ns2:xxMmSender xmlns:ns2="http://xxx.com/"><arg0 xmlns="">` + phone + `</arg0><arg1 xmlns="">` +     msg + `</arg1><arg2 xmlns="">yunwei.alarm</arg2><arg3     xmlns=""></arg3></ns2:xxMmSender></S:Body></    S:Envelope>`
    log.Println(strings.NewReader(body))
    req, err := http.NewRequest("post", uri,     bytes.NewBuffer([]byte(body)))
    if err != nil {
        log.Println(err)
        // handle error
    }
    req.Host = "xxx.com"
    resp, err := client.Do(req)
    if err != nil {
        log.Println(err)
    }
    log.Println(resp)
    //log.Println(respbody)
    return err
}

func main() {
    sendmessage("135xxxxxxx", "testGolang")
}
然而我发现此请求并没有获取到短信，于是挂上代理进行抓包，发现其响应码为502.

对比Python的正常请求：

发现是因为http.NewRequest()方法第一个参数options方法写错了，不能写成小写..