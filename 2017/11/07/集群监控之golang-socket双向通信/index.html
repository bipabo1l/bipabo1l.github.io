<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 集群监控之golang socket双向通信 · Bipabo1l's Blog</title><meta name="description" content="集群监控之golang socket双向通信 - Bipabo1l"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Bipabo1l's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/2610095341/profile" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/bipabo1l" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">集群监控之golang socket双向通信</h1><div class="post-info">2017年11月7日</div><div class="post-content"><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本例中，40台机器构建成一个集群，完成对IP存活的扫描以及调用nmap扫描ip段，通过golang socket将一台Server机器与30余台Agent机器建立双向通信机制，支持断线重连，已完成Server端对Agent的扫描情况、是否在工作的监控，通过Beego+Layui研发web页面以管理。</p>
<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><p>Server端本地监听自己的8848端口，供与client端通信，同时启动自己的8849端口作为web端口，接受来自web端的请求，client端会尝试与Server端通信，一旦建立连接，会以全双工的方式，建立双向通信管道。在一个conn连接下server与client互联，互相发送请求与状态。<br>代码地址：<br>    <a href="https://github.com/bipabo1l/TyrantSocket" target="_blank" rel="external">https://github.com/bipabo1l/TyrantSocket</a><br>关键代码如下：<br>Server端：<br>    package main</p>
<pre><code>import (
    &quot;GoRadar/core&quot;
    &quot;GoRadar/lib&quot;
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;os&quot;
    &quot;os/exec&quot;
    &quot;path/filepath&quot;
    &quot;strings&quot;
    &quot;sync&quot;
    &quot;time&quot;

    &quot;github.com/benmanns/goworker&quot;
    &quot;gopkg.in/mgo.v2/bson&quot;
    &quot;github.com/bipabo1l/TyrantSocket/protocol&quot;
    &quot;net/http&quot;
    )

    var waitgroup sync.WaitGroup
    var mIPRangePool lib.MongoDriver
    var is_private int
    var scan_mode_param string
    var is_limit_scan_rate bool
    var IPRange1 string

    type IPRangePool struct {
        IPRange string `bson:&quot;ip_range&quot;`
    }

    //记录所有Agent
    var clientArr = make(map[string]net.Conn)
    var ipRangeArr = make(map[string]string)

    type AgentMsg struct {
        Session int64
        IP      string
        Message string
        Status  string
    }

    //定义CheckError方法，避免写太多到 if err!=nil
    func CheckError(err error) {

        if err != nil {
            fmt.Fprintf(os.Stderr, &quot;Fatal error:%s&quot;, err.Error())

            os.Exit(1)
        }

    }

    //自定义log
    func Log(v ...interface{}) {

        log.Println(v...)
    }

    var ch1 = make(chan int, 1)

    func init() {

        cfg := lib.NewConfigUtil(&quot;&quot;)
        redis_host, _ := cfg.GetString(&quot;redis_default&quot;, &quot;host&quot;)
        redis_port, _ := cfg.GetString(&quot;redis_default&quot;, &quot;port&quot;)
        redis_pass, _ := cfg.GetString(&quot;redis_default&quot;, &quot;pass&quot;)
        redis_db, _ := cfg.GetString(&quot;redis_default&quot;, &quot;db&quot;)

        var dsn_addr string
        if redis_pass != &quot;&quot; {
            dsn_addr = fmt.Sprintf(&quot;redis://:%s@%s:%s/%s&quot;, redis_pass, redis_host, redis_port, redis_db)
        } else {
            dsn_addr = fmt.Sprintf(&quot;redis://%s:%s/%s&quot;, redis_host, redis_port, redis_db)
        }

        // 初始化
        settings := goworker.WorkerSettings{
            URI:            dsn_addr,
            Connections:    100,
            Queues:         []string{&quot;scannerQueue&quot;, &quot;ScanPortQuene&quot;},
            UseNumber:      true,
            ExitOnComplete: false,
            Concurrency:    2,
            Namespace:      &quot;goradar:&quot;,
            Interval:       5.0,
        }

        goworker.SetSettings(settings)

        // 初始化数据库连接
        mIPRangePool = lib.MongoDriver{TableName: &quot;ip_range_pool&quot;}
        err := mIPRangePool.Init()
        if err != nil {
            fmt.Println(&quot;INIT MONGODB ERRPR:&quot; + err.Error())
        }

        //initialize deploy mode
        deploy, _ := cfg.GetString(&quot;server_default&quot;, &quot;deploy&quot;)
        if deploy == &quot;inner&quot; {

            is_private = 1
            scan_mode_param = &quot;q&quot;
            is_limit_scan_rate = true
        } else if deploy == &quot;outer&quot; {
            is_private = 2
            scan_mode_param = &quot;d&quot;
            is_limit_scan_rate = false
        } else {
            fmt.Println(&quot;config server_defaul-&gt;deploy error: only &apos;inner&apos; or &apos;outer&apos; allowed&quot;)
            os.Exit(1)
        }
    }

    func main() {

        // 加入守护进程机制

        if os.Getppid() != 1 {
            //判断当其是否是子进程，当父进程return之后，子进程会被 系统1 号进程接管
            filePath, _ := filepath.Abs(os.Args[0])
            //将命令行参数中执行文件路径转换成可用路径
            cmd := exec.Command(filePath)
            //将其他命令传入生成出的进程
            cmd.Stdin = os.Stdin
            //给新进程设置文件描述符，可以重定向到文件中
            cmd.Stdout = os.Stdout
            cmd.Stderr = os.Stderr
            //开始执行新进程，不等待新进程退出
            cmd.Start()
            return
        }

        //mode_param := flag.String(&quot;mode&quot;, &quot;q&quot;, &quot;for quick scan: -mode q , for detail scan -mode d ;default -mode q &quot;)
        //if *mode_param != &quot;q&quot; &amp;&amp; *mode_param != &quot;d&quot; {
        //    fmt.Println(&quot;for quick scan: -mode q , for detail scan -mode d ; default -mode q&quot;)
        //    os.Exit(1)
        //}

        waitgroup.Add(3)

        go ListenMsg()

        // 清理昨天数据(5分钟)
        go func() {
            for {
                timer1 := time.NewTimer(time.Minute * 5)
                &lt;-timer1.C
                cna := core.NewClearNotActivity()
                cna.Clear()
                fmt.Println(&quot;清理完成&quot;)
            }
        }()

        // 添加任务(10分钟)
        go func() {

            // 首次运行
            one_run := true

            for {

                if one_run == false {
                    timer1 := time.NewTimer(time.Minute * 10)
                    &lt;-timer1.C
                }

                // 添加扫描任务
                IPRangePool := new([]IPRangePool)
                ip_range_pool, err := mIPRangePool.NewTable()
                if err == nil {

                    // TODO 由于扫内网存活会造成大量Arp请求，目前暂时只扫描外网IP段
                    ip_range_pool.Find(bson.M{&quot;is_private&quot;: is_private}).All(IPRangePool)
                    for _, ip_range := range *IPRangePool {

                        fmt.Println(&quot;添加一条存活探测任务:&quot; + ip_range.IPRange)
                        // 不阻塞,增加扫描任务
                        goworker.Enqueue(&amp;goworker.Job{
                            Queue: &quot;ScanActivityQueue&quot;,
                            Payload: goworker.Payload{
                                Class: &quot;ScanActivityTask&quot;,
                                Args:  []interface{}{string(ip_range.IPRange), is_limit_scan_rate},
                            },
                        })

                    }

                } else {
                    fmt.Println(&quot;ERROR:&quot; + err.Error())
                }

                one_run = false
            }
        }()

        // 添加端口扫描任务(5)
        go func() {

            // 首次运行
            one_run := true
            for {

                if one_run == false {
                    timer1 := time.NewTimer((time.Hour * 24) * 2)
                    &lt;-timer1.C
                }

                // 添加扫描任务
                IPRangePool := new([]IPRangePool)
                ip_range_pool, err := mIPRangePool.NewTable()
                if err == nil {

                    // TODO 由于扫外网占用大量session表，目前暂时只扫描内网
                    ip_range_pool.Find(bson.M{&quot;is_private&quot;: is_private}).All(IPRangePool)
                    for _, ip_range := range *IPRangePool {
                        fmt.Println(&quot;添加一条端口扫描任务:&quot; + ip_range.IPRange)
                        // 不阻塞,增加扫描任务
                        goworker.Enqueue(&amp;goworker.Job{
                            Queue: &quot;ScanPortQuene&quot;,
                            Payload: goworker.Payload{
                                Class: &quot;ScanPortTask&quot;,
                                Args:  []interface{}{string(ip_range.IPRange), scan_mode_param, is_limit_scan_rate},
                            },
                        })
                    }

                } else {
                    fmt.Println(&quot;ERROR:&quot; + err.Error())
                }

                one_run = false
            }
        }()

        waitgroup.Wait()

        fmt.Println(&quot;添加任务完成&quot;)
    }

    ////自定义log
    //func Log(v ...interface{}) {
    //
    //    log.Println(v...)
    //}

    func ListenMsg() {
        server_listener, err := net.Listen(&quot;tcp&quot;, &quot;192.168.0.8:8848&quot;)
        //server_listener, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:8848&quot;)

        CheckError(err)

        defer server_listener.Close()

        Log(&quot;Waiting for clients connect&quot;)

        go getConn()

        for {
            new_conn, err := server_listener.Accept()

            clientIPList := strings.Split(new_conn.RemoteAddr().String(), &quot;:&quot;)

            clientIP := new_conn.RemoteAddr().String()
            if len(clientIPList) &gt; 0 {
                clientIP = clientIPList[0]
            }
            log.Println(clientIP)
            clientArr[clientIP] = new_conn

            CheckError(err)

            log.Println(new_conn.RemoteAddr().String() + &quot; 上线了&quot;)

            go ServerMsgHandler(new_conn)
        }
    }
    func getConn() {
        http.HandleFunc(&quot;/&quot;, sayhelloName)
        err := http.ListenAndServe(&quot;:8849&quot;, nil)
        if err != nil {
            log.Fatal(&quot;ListenAndServe: &quot;, err)
        }
    }

    type IPList struct {
        IPPort   string   `json:&quot;ipport&quot;`
        ConnList net.Conn `json:&quot;netconn&quot;`
    }

    type IPListMap struct {
        IPListMap []IPList
    }

    func sayhelloName(w http.ResponseWriter, r *http.Request) {

        r.ParseForm()
        key := &quot;&quot;
        value := &quot;&quot;
        sign := 0
        for k, v := range r.Form {
            if k != &quot;&quot; &amp;&amp; strings.Join(v, &quot;&quot;) != &quot;&quot; {
                key = k
                value = strings.Join(v, &quot;&quot;)
            }
        }

        //监听8849端口判断批量getStatus动作
        if key == &quot;key&quot; &amp;&amp; value == &quot;getstatus&quot; {
            data, err := json.Marshal(clientArr)
            if err != nil {
                log.Println(err)
                return
            }
            s := strings.Split(string(data[:]), &quot;,&quot;)
            ll := &quot;&quot;
            if len(s) &gt; 0 {
                for _, w := range s {
                    k := strings.Split(w, &quot;:&quot;)
                    if len(k) &gt; 0 &amp;&amp; ll != &quot;&quot; {
                        ll = ll + &quot;,&quot; + k[0]
                        ll = strings.Replace(ll, &quot;{&quot;, &quot;&quot;, -1)
                        ll = strings.Replace(ll, `&quot;`, &quot;&quot;, -1)
                        ll = strings.Replace(ll, `}`, &quot;&quot;, -1)
                    } else if len(k) &gt; 0 {
                        ll = k[0]
                        ll = strings.Replace(ll, &quot;{&quot;, &quot;&quot;, -1)
                        ll = strings.Replace(ll, `&quot;`, &quot;&quot;, -1)
                        ll = strings.Replace(ll, `}`, &quot;&quot;, -1)
                    }
                }
            }

            fmt.Fprintf(w, `{&quot;Agent&quot;:&quot;`+ll+`&quot;}`)
        } else if key == &quot;key&quot; &amp;&amp; strings.Count(value, &quot;&quot;)-1 &gt;= 4 {
            if protocol.Substr2(value, 0, 4) == &quot;stop&quot; {
                sign = 1
                ip := protocol.Substr2(value, 4, len(value))

                log.Println(&quot;-----------------------------&quot;)
                log.Println(clientArr)

                findConn := clientArr[ip]

                go StopClient(findConn)

                fmt.Fprintf(w, &quot;1&quot;)
            }

            if strings.Count(value, &quot;&quot;)-1 &gt;= 5 &amp;&amp; sign == 0 {
                if protocol.Substr2(value, 0, 5) == &quot;start&quot; {
                    sign = 1
                    ip := protocol.Substr2(value, 5, len(value))

                    log.Println(&quot;-----------------------------&quot;)
                    log.Println(clientArr)

                    findConn := clientArr[ip]

                    go BeginClient(findConn)

                    fmt.Fprintf(w, &quot;1&quot;)
                }
            }

            if strings.Count(value, &quot;&quot;)-1 &gt;= 10 &amp;&amp; sign == 0 {
                if protocol.Substr2(value, 0, 10) == &quot;getiprange&quot; {
                    log.Println(&quot;服务端请求当前扫描的IPRange&quot;)
                    ip := protocol.Substr2(value, 10, len(value))
                    log.Println(&quot;服务端接收到ip:&quot;)
                    log.Println(ip)
                    fmt.Println(clientArr)
                    fmt.Println(ipRangeArr)
                    if _, ok := clientArr[ip]; ok {
                        go IPRangeClient(clientArr[ip])
                    }
                    if len(ipRangeArr) &gt; 0 {
                        //by, err := json.Marshal(ipRangeArr)
                        //if err != nil {
                        //    log.Println(err)
                        //}
                        //fmt.Fprintf(w, string(by))
                        if _, ok := ipRangeArr[ip]; ok {
                            fmt.Fprintf(w, `{&quot;IPrange&quot;:&quot;`+ipRangeArr[ip]+`&quot;}`)
                        }

                    } else {
                        fmt.Fprintf(w, `{&quot;IPrange&quot;:&quot;`+`&quot;}`)
                    }

                }
            }
        }
    }

    //服务端消息处理
    func ServerMsgHandler(conn net.Conn) {

        //存储被截断的数据
        tmpbuf := make([]byte, 0)
        buf := make([]byte, 1024)

        defer conn.Close()

        //接收解包
        readchan := make(chan []byte, 16)
        go ReadChan(readchan)

        for {
            //读取客户端发来的消息
            n, err := conn.Read(buf)

            if err != nil {

                fmt.Println(&quot;connection close&quot;)
                removeClient(conn)
                conn.Close()
                return
            }

            //解包
            tmpbuf = protocol.Depack(append(tmpbuf, buf[:n]...))
            //tmpbuf = buf

            fmt.Println(&quot;client say:&quot;, string(tmpbuf))

            //判断解析json
            var agentmsg AgentMsg
            json.Unmarshal([]byte(string(tmpbuf)), &amp;agentmsg)
            Msg := tmpbuf
            log.Println(agentmsg.Status)
            if agentmsg.Status == &quot;STOPPED&quot; {
                removeClient(conn)
            }

            if agentmsg.Status == &quot;IPRange&quot; {
                log.Println(&quot;Agent.Sattus&quot;)
                IPRange1 = agentmsg.Message
                ipRangeArr[agentmsg.IP] = agentmsg.Message
            }

            //向客户端发送消息
            go WriteMsgToClient(conn)

            go func() {
                if &lt;-ch1 == 2 {
                    WriteMsgToClient2(conn)
                }
            }()

            beatch := make(chan byte)
            //心跳计时，默认30秒
            go HeartBeat(conn, beatch, 30)
            //检测每次Client是否有数据传来
            go HeartChanHandler(Msg, beatch)

        }

    }

    //处理心跳,根据HeartChanHandler判断Client是否在设定时间内发来信息
    func HeartBeat(conn net.Conn, heartChan chan byte, timeout int) {
        select {
        case hc := &lt;-heartChan:
            Log(&quot;&lt;-heartChan:&quot;, string(hc))
            conn.SetDeadline(time.Now().Add(time.Duration(timeout) * time.Second))
            break
        case &lt;-time.After(time.Second * 30):
            Log(&quot;timeout&quot;)
            conn.Close()
        }
    }

    //服务端向客户端发送消息
    func WriteMsgToClient(conn net.Conn) {
        log.Println(conn.RemoteAddr())
        talk := &quot;RUN&quot;
        smsg := protocol.Enpack([]byte(talk))
        conn.Write(smsg)
    }

    func WriteMsgToClient2(conn net.Conn) {
        talk := &quot;GETSTATUS&quot;
        smsg := protocol.Enpack([]byte(talk))
        conn.Write(smsg)
    }

    //Server表示不想跟您通信咯
    func StopClient(conn net.Conn) {
        talk := &quot;STOP&quot;
        smsg := protocol.Enpack([]byte(talk))
        conn.Write(smsg)
    }

    //Server表示不想跟您通信咯
    func BeginClient(conn net.Conn) {
        talk := &quot;BEGIN&quot;
        smsg := protocol.Enpack([]byte(talk))
        conn.Write(smsg)
    }

    func IPRangeClient(conn net.Conn) {
        talk := &quot;IPRANGE&quot;
        smsg := protocol.Enpack([]byte(talk))
        conn.Write(smsg)
    }

    //处理心跳channel
    func HeartChanHandler(n []byte, beatch chan byte) {
        for _, v := range n {
            beatch &lt;- v
            log.Println(v)
        }
        close(beatch)
    }

    //从channell中读取数据
    func ReadChan(readchan chan []byte) {

        for {
            select {
            case data := &lt;-readchan:
                Log(string(data))
            }
        }
    }

    func removeClient(new_conn net.Conn) {
        log.Println(clientArr)
        log.Println(new_conn.RemoteAddr().String() + &quot; 已经阵亡&quot;)

        clientIPList := strings.Split(new_conn.RemoteAddr().String(), &quot;:&quot;)

        clientIP := new_conn.RemoteAddr().String()
        if len(clientIPList) &gt; 0 {
            clientIP = clientIPList[0]
        }
        log.Println(clientIP)

        delete(clientArr, clientIP)
        log.Println(&quot;delete close conn&quot;)
        log.Println(clientArr)
        return
    }
</code></pre><p>client端：</p>
<pre><code>package main

import (
    &quot;GoRadar/core&quot;
    &quot;GoRadar/lib&quot;
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/http&quot;
    &quot;os&quot;
    &quot;os/exec&quot;
    &quot;path/filepath&quot;
    &quot;runtime&quot;
    &quot;strconv&quot;
    &quot;time&quot;

    &quot;github.com/benmanns/goworker&quot;
    &quot;github.com/levigross/grequests&quot;
    &quot;github.com/bipabo1l/TyrantSocket/protocol&quot;
)

//ch1 为-1时，与server端停止通信
var chSign = make(chan int, 1)
//var IPrange = make([]string, 0, 100)
//var IPPortrange = make([]string, 0, 100)
var IPRange = &quot;&quot;
var IPPortrange = &quot;&quot;

// 扫描
func ScanActivityTask(queue string, args ...interface{}) error {
    fmt.Println(&quot;调用队列:&quot; + queue)
    ip_range := args[0].(string)
    //IPrange = append(IPrange, ip_range)
    IPRange = ip_range
    is_limit_scan_rate := args[1].(bool)
    sa := core.NewScanActivity()
    sa.Scanner(ip_range, is_limit_scan_rate)
    return nil
}
func ScanPortTask(queue string, args ...interface{}) error {
    fmt.Println(&quot;调用队列:&quot; + queue)
    ip_range := args[0].(string)
    //IPPortrange = append(IPPortrange, ip_range)
    IPPortrange = ip_range
    scan_mode := args[1].(string)
    is_limit_scan_rate := args[2].(bool)
    sa := core.NewScanPort()
    sa.Scan(ip_range, scan_mode, is_limit_scan_rate)
    return nil
}

var (
    version      = &quot;1.0.6&quot;
    download_url = &quot;&quot;
)

func Version_validate(c chan string) bool {
    resp, err := grequests.Get(&quot;http://43.226.164.114/version.txt&quot;, nil)
    // You can modify the request by passing an optional RequestOptions struct
    if err != nil {
        fmt.Println(&quot;Validate version error: Unable to make request &quot;)
        return false
    } else {
        new_version := resp.String()[0:5]
        fmt.Println(&quot;new_version:&quot; + new_version)
        fmt.Println(&quot;version:&quot; + version)
        if version &lt; new_version {
            os_name := runtime.GOOS
            if os_name == &quot;linux&quot; {
                download_url = &quot;http://43.226.164.114/linux/&quot; + new_version
            } else if os_name == &quot;windows&quot; {
                download_url = &quot;http://43.226.164.114/windows/&quot; + new_version
            }
            download, _ := Download_new_agent(download_url, os_name)
            if download == true {
                c &lt;- &quot;new&quot;
                fmt.Println(&quot;New agent version found !&quot;)
                return true
            } else {
                c &lt;- &quot;old&quot;
                return false
            }
        } else {
            return false
        }
    }
}

func Download_new_agent(url string, os_name string) (bool, error) {
    res, err := http.Get(url)
    if err != nil {
        return false, err
    }
    var (
        file_name string
    )
    if os_name == &quot;windows&quot; {
        file_name = &quot;Agent.exe&quot;
    } else if os_name == &quot;linux&quot; {
        file_name = &quot;Agent&quot;
    } else {
        file_name = &quot;Agent&quot;
    }
    cmd := exec.Command(&quot;rm&quot;, &quot;-rf&quot;, file_name)
    cmd.Run()
    f, err := os.Create(file_name)
    if err != nil {
        return false, err
    }
    _, er := io.Copy(f, res.Body)
    if er != nil {
        return false, er
    }
    if os_name == &quot;linux&quot; {
        cmdd := exec.Command(&quot;chmod&quot;, &quot;+x&quot;, file_name)
        cmdd.Run()
    }
    res.Body.Close()
    f.Close()
    return true, er

}

func Restart_process() {
    filePath, _ := filepath.Abs(os.Args[0])
    cmd := exec.Command(filePath)
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    err := cmd.Start()
    if err != nil {
        log.Fatalf(&quot;GracefulRestart: Failed to launch, error: %v&quot;, err)
    }
}

func init() {

    cfg := lib.NewConfigUtil(&quot;&quot;)
    redis_host, _ := cfg.GetString(&quot;redis_default&quot;, &quot;host&quot;)
    redis_port, _ := cfg.GetString(&quot;redis_default&quot;, &quot;port&quot;)
    redis_pass, _ := cfg.GetString(&quot;redis_default&quot;, &quot;pass&quot;)
    redis_db, _ := cfg.GetString(&quot;redis_default&quot;, &quot;db&quot;)
    var dsn_addr string
    if redis_pass != &quot;&quot; {
        dsn_addr = fmt.Sprintf(&quot;redis://:%s@%s:%s/%s&quot;, redis_pass, redis_host, redis_port, redis_db)
    } else {
        dsn_addr = fmt.Sprintf(&quot;redis://%s:%s/%s&quot;, redis_host, redis_port, redis_db)
    }

    settings := goworker.WorkerSettings{
        URI:            dsn_addr,
        Connections:    100,
        Queues:         []string{&quot;ScanActivityQueue&quot;, &quot;ScanPortQuene&quot;},
        UseNumber:      true,
        ExitOnComplete: false,
        Concurrency:    50,
        Namespace:      &quot;goradar:&quot;,
        Interval:       5.0,
    }

    goworker.SetSettings(settings)
    //read scan option
    activeswitch, _ := cfg.GetString(&quot;agent_default&quot;, &quot;scanactivity&quot;)
    portswitch, _ := cfg.GetString(&quot;agent_default&quot;, &quot;scanport&quot;)
    if activeswitch == &quot;yes&quot; {
        goworker.Register(&quot;ScanActivityTask&quot;, ScanActivityTask)
        fmt.Println(&quot;Start active scan !&quot;)
    } else if activeswitch == &quot;no&quot; {
        fmt.Println(&quot;Doesn&apos;t start active scan !&quot;)
    } else {
        fmt.Println(&quot;Error: config anget-&gt;scanactivity param error, only &apos;yes&apos; or &apos;no&apos; allowed&quot;)
    }
    if portswitch == &quot;yes&quot; {
        goworker.Register(&quot;ScanPortTask&quot;, ScanPortTask)
        fmt.Println(&quot;Start ports scan !&quot;)
    } else if portswitch == &quot;no&quot; {
        fmt.Println(&quot;Doesn&apos;t start ports scan !&quot;)
    } else {
        fmt.Println(&quot;Error: Config anget-&gt;scanport param error,only &apos;yes&apos; or &apos;no&apos; allowed&quot;)
    }
}

func main() {

    // 加入守护进程机制

    if os.Getppid() != 1 {
        //判断当其是否是子进程，当父进程return之后，子进程会被 系统1 号进程接管
        filePath, _ := filepath.Abs(os.Args[0])
        //将命令行参数中执行文件路径转换成可用路径
        cmd := exec.Command(filePath)
        //将其他命令传入生成出的进程
        cmd.Stdin = os.Stdin
        //给新进程设置文件描述符，可以重定向到文件中
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        //开始执行新进程，不等待新进程退出
        cmd.Start()
        return
    }

    signals := make(chan string)
    go func() {
        for {
            Version_validate(signals)
            time.Sleep(1 * time.Minute)
        }

    }()

    go func() {
        for {
            log.Println(&quot;GOWoker Running&quot;)
            err := goworker.Work()
            if err != nil {
                fmt.Println(&quot;Error:&quot;, err)
            }

        }
    }()

    go func() {
        sendMsgToServer()
    }()

    for {
        select {
        case signal := &lt;-signals:
            if signal == &quot;new&quot; {
                Restart_process()
                return
            }
        case &lt;-time.After(time.Second * 10):
            fmt.Println(&quot;timeout, check again...&quot;)
            continue
        }
    }
}

func sendMsgToServer() {
    //动态传入服务端IP和端口号
    service := &quot;192.168.0.8:8848&quot;
    //service := &quot;127.0.0.1:8848&quot;

    tcpAddr, err := net.ResolveTCPAddr(&quot;tcp4&quot;, service)

    CheckError(err)

    for {

        conn, err := net.DialTCP(&quot;tcp&quot;, nil, tcpAddr)

        if err != nil {
            fmt.Fprintf(os.Stderr, &quot;Fatal error:%s&quot;, err.Error())
        } else {
            defer conn.Close()

            //连接服务器端成功
            doWork(conn)
        }

        time.Sleep(3 * time.Second)

    }
}

//定义CheckError方法，避免写太多到 if err!=nil
func CheckError(err error) {

    if err != nil {
        fmt.Fprintf(os.Stderr, &quot;Fatal error:%s&quot;, err.Error())

        os.Exit(1)
    }

}

//解决断线重连问题
func doWork(conn net.Conn) error {
    ch := make(chan int, 100)

    ticker := time.NewTicker(time.Second)
    defer ticker.Stop()
    for {
        select {
        case stat := &lt;-ch:
            if stat == 2 {
                return errors.New(&quot;None Msg&quot;)
            }
        case &lt;-ticker.C:
            ch &lt;- 1
            go ClientMsgHandler(conn, ch)
            go ReadMsg(conn, ch)
        case &lt;-time.After(time.Second * 2):
            defer conn.Close()
            fmt.Println(&quot;timeout&quot;)
        }

    }

    return nil
}

//客户端消息处理
func ClientMsgHandler(conn net.Conn, ch chan int) {

    &lt;-ch
    //获取当前时间
    //msg := &quot;+++++++++++++++++++++++++++++++++++++&quot;
    SendMsg(conn, &quot;rrrrr&quot;)
    go ReadMsg(conn, ch)

}

func GetSession() string {
    gs1 := time.Now().Unix()
    gs2 := strconv.FormatInt(gs1, 10)
    return gs2
}

//接收服务端发来的消息
func ReadMsg(conn net.Conn, ch chan int) {
    &lt;-ch

    //存储被截断的数据
    tmpbuf := make([]byte, 0)
    buf := make([]byte, 1024)

    //将信息解包
    n, _ := conn.Read(buf)
    tmpbuf = protocol.Depack(append(tmpbuf, buf[:n]...))
    msg := string(tmpbuf)
    fmt.Println(&quot;server say:&quot;, msg)
    if len(msg) == 0 {
        //服务端无返回信息
        ch &lt;- 2
    } else {
        //接收到了服务器端发来的非空包，证明已经和服务器连接成功
        if msg == &quot;RUN&quot; {
            log.Println(&quot;收到服务器命令：发送Running包&quot;)
            go func() {
                SendMsg(conn, msg)
                time.Sleep(time.Second * 2)
            }()
        } else if msg == &quot;GETSTATUS&quot; {
            //服务器端想知道当前在没在工作
            log.Println(&quot;Server端请求了解本Agent状态&quot;)
            go SendRunMsg(conn, msg)
        } else if msg == &quot;STOP&quot; {
            //服务器让当前agent停止
            log.Println(&quot;服务器让当前agent停止&quot;)
            go func() {
                StopRunMsg(conn, msg)
                chSign &lt;- -1
            }()
            //go StopRunMsg(conn, msg)
            //conn.Close()
        } else if msg == &quot;BEGIN&quot; {
            //服务器让当前agent停止
            log.Println(&quot;服务器让当前agent重新连接&quot;)
            go BeginRunMsg(conn, msg)
            //conn.Close()
        } else if msg == &quot;IPRANGE&quot; {
            //服务器让当前agent停止
            log.Println(&quot;服务器需要当前IPrange&quot;)
            log.Println(IPRange)
            go IPRangeMsg(conn, IPRange)
        }
    }
}

//向服务端发送消息
func SendMsg(conn net.Conn, msg string) {

    session := GetSession()

    words := &quot;{\&quot;Session\&quot;:&quot; + session + &quot;,\&quot;IP\&quot;:\&quot;&quot; + GetMyIP() + &quot;\&quot;,\&quot;Message\&quot;:\&quot;&quot; + msg + &quot;\&quot;,\&quot;Status\&quot;:\&quot;&quot; + &quot;running&quot; + &quot;\&quot;}&quot;
    //将信息封包
    smsg := protocol.Enpack([]byte(words))
    conn.Write(smsg)

}

//向服务端发送消息
func SendRunMsg(conn net.Conn, msg string) {

    session := GetSession()
    words := &quot;{\&quot;Session\&quot;:&quot; + session + &quot;,\&quot;IP\&quot;:\&quot;&quot; + GetMyIP() + &quot;\&quot;,\&quot;Message\&quot;:\&quot;&quot; + msg + &quot;\&quot;,\&quot;Status\&quot;:\&quot;&quot; + &quot;IAMRunning&quot; + &quot;\&quot;}&quot;
    //将信息封包
    smsg := protocol.Enpack([]byte(words))
    conn.Write(smsg)

}

//向服务端发送消息
func StopRunMsg(conn net.Conn, msg string) {

    session := GetSession()
    words := &quot;{\&quot;Session\&quot;:&quot; + session + &quot;,\&quot;IP\&quot;:\&quot;&quot; + GetMyIP() + &quot;\&quot;,\&quot;Message\&quot;:\&quot;&quot; + msg + &quot;\&quot;,\&quot;Status\&quot;:\&quot;&quot; + &quot;STOPPED&quot; + &quot;\&quot;}&quot;
    //将信息封包
    smsg := protocol.Enpack([]byte(words))
    conn.Write(smsg)
    log.Println(&quot;----------------------------------&quot;)
    conn.Close()
}

//向服务端发送消息
func BeginRunMsg(conn net.Conn, msg string) {
    session := GetSession()
    words := &quot;{\&quot;Session\&quot;:&quot; + session + &quot;,\&quot;IP\&quot;:\&quot;&quot; + GetMyIP() + &quot;\&quot;,\&quot;Message\&quot;:\&quot;&quot; + msg + &quot;\&quot;,\&quot;Status\&quot;:\&quot;&quot; + &quot;Begin&quot; + &quot;\&quot;}&quot;
    //将信息封包
    smsg := protocol.Enpack([]byte(words))
    conn.Write(smsg)
    log.Println(&quot;----------------------------------&quot;)
}

func IPRangeMsg(conn net.Conn, msg string) {
    session := GetSession()
    words := &quot;{\&quot;Session\&quot;:&quot; + session + &quot;,\&quot;IP\&quot;:\&quot;&quot; + GetMyIP() + &quot;\&quot;,\&quot;Message\&quot;:\&quot;&quot; + msg + &quot;\&quot;,\&quot;Status\&quot;:\&quot;&quot; + &quot;IPRange&quot; + &quot;\&quot;}&quot;
    //将信息封包
    smsg := protocol.Enpack([]byte(words))
    conn.Write(smsg)
    log.Println(&quot;----------------------------------&quot;)
}

func GetMyIP() string {
    addrs, err := net.InterfaceAddrs()
    ip := &quot;&quot;
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }

    for _, address := range addrs {

        // 检查ip地址判断是否回环地址
        if ipnet, ok := address.(*net.IPNet); ok &amp;&amp; !ipnet.IP.IsLoopback() {
            if ipnet.IP.To4() != nil {
                ip = ipnet.IP.String()
            }

        }
    }
    return ip
}

func get_external() string {
    resp, err := http.Get(&quot;http://myexternalip.com/raw&quot;)
    if err != nil {
        return &quot;&quot;
    }
    defer resp.Body.Close()
    content, _ := ioutil.ReadAll(resp.Body)
    log.Println(&quot;++++++++++++++++++++++++++++++++++++++++++++&quot;)
    log.Println(string(content))
    return string(content)

}
</code></pre><p>执行截图如下：<br>Server端：并行push任务到redis中并监听Agent情况<br><img src="http://ovnsp3bhk.bkt.clouddn.com/Snipaste_2017-11-07_17-41-35.png" alt=""><br>Client端一方面读取Redis任务并开始工作，另一方面时时读取Server端的请求并执行工作<br><img src="http://ovnsp3bhk.bkt.clouddn.com/Snipaste_2017-11-07_17-50-52.png" alt=""></p>
<p>web端展示页面如下：<br><img src="https://camo.githubusercontent.com/f56e9a31c1eae142b4bf7a1d26964be50c61d708/687474703a2f2f6f766e73703362686b2e626b742e636c6f7564646e2e636f6d2f536e6970617374655f323031372d31312d30375f31362d31352d31372e706e67" alt=""></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/01/12/scrapy-cluster分布式url爬虫集群/" class="prev">上一篇</a><a href="/2017/09/22/解决golang-post-xml数据带header时502bad-gateway-的问题/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">Bipabo1l</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>