<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bipabo1l&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/f12afe463f30521d5f4d7321a2b377d6</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-09-25T03:22:28.656Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Bipabo1l</name>
    <email>bipabo1l@csoio.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次golang post xml时返回502错误码的问题</title>
    <link href="http://yoursite.com/2017/09/22/%E8%A7%A3%E5%86%B3golang-post-xml%E6%95%B0%E6%8D%AE%E5%B8%A6header%E6%97%B6502bad-gateway-%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/09/22/解决golang-post-xml数据带header时502bad-gateway-的问题/</id>
    <published>2017-09-22T03:28:58.000Z</published>
    <updated>2017-09-25T03:22:28.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><p>昨天由于项目需要，加入发送短信功能，首先测试了一下已存在的一个Python代码，原理比较简单，向一个接口发送一个http post请求，请求的数据为xml格式，同时请求会带一个header头，Key为Host信息。</p><p>Python代码如下：</p><pre><code># coding=utf-8import requestsimport cgidef send(phone, msg):    url = &apos;http://xxx.com/MoblMsgSender&apos;    headers = {        &apos;Host&apos;: &apos;xxx.com&apos;,    }    body = &apos;&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;S:Envelope xmlns:S=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&lt;S:Header&gt;&lt;AuthenticationHeader xmlns=&quot;http://xxx.com/MoblMsgSender&quot;&gt;&lt;Token&gt;Tokenxxx==&lt;/Token&gt;&lt;/AuthenticationHeader&gt;&lt;/S:Header&gt;&lt;S:Body&gt;&lt;ns2:xxMmSender xmlns:ns2=&quot;http://xxx.com/&quot;&gt;&lt;arg0 xmlns=&quot;&quot;&gt;%s&lt;/arg0&gt;&lt;arg1 xmlns=&quot;&quot;&gt;%s&lt;/arg1&gt;&lt;arg2 xmlns=&quot;&quot;&gt;yunwei.alarm&lt;/arg2&gt;&lt;arg3 xmlns=&quot;&quot;&gt;&lt;/arg3&gt;&lt;/ns2:xxMmSender&gt;&lt;/S:Body&gt;&lt;/S:Envelope&gt;&apos; % (phone, cgi.escape(msg))    try:        r = requests.post(url, data=body, headers=headers)        if &apos;&lt;return&gt;true&lt;/return&gt;&apos; in r.content:            return True    except:        pass    return Falsesend(&quot;135xxxxxxx&quot;,&quot;testPython&quot;)</code></pre><a id="more"></a><p>果然成功收到了短信，证明接口调用成功。<br><img src="http://ovnsp3bhk.bkt.clouddn.com/Snipaste_2017-09-22_11-51-57.png" alt=""><br>于是我转化成golang代码：</p><pre><code>package mainimport (    &quot;bytes&quot;    &quot;crypto/tls&quot;    &quot;log&quot;    &quot;net/http&quot;    &quot;strings&quot;    &quot;time&quot;)func sendmessage(phone string, msg string) error {    uri := `http://xxx.com/MoblMsgSender`    //proxy, _ := url.Parse(&quot;http://127.0.0.1:8080&quot;)    tr := &amp;http.Transport{        //Proxy:           http.ProxyURL(proxy),        TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true},    }    client := &amp;http.Client{        Transport: tr,        Timeout:   time.Second * 5, //超时时间    }    body := `&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;S:Envelope xmlns:S=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&lt;S:Header&gt;&lt;AuthenticationHeader xmlns=&quot;http://mms.360buy.com/services/MoblMsgSender&quot;&gt;&lt;Token&gt;666a8EN3oIijHY+KjS+2mg==&lt;/Token&gt;&lt;/AuthenticationHeader&gt;&lt;/S:Header&gt;&lt;S:Body&gt;&lt;ns2:xxMmSender xmlns:ns2=&quot;http://xxx.com/&quot;&gt;&lt;arg0 xmlns=&quot;&quot;&gt;` + phone + `&lt;/arg0&gt;&lt;arg1 xmlns=&quot;&quot;&gt;` +     msg + `&lt;/arg1&gt;&lt;arg2 xmlns=&quot;&quot;&gt;yunwei.alarm&lt;/arg2&gt;&lt;arg3     xmlns=&quot;&quot;&gt;&lt;/arg3&gt;&lt;/ns2:xxMmSender&gt;&lt;/S:Body&gt;&lt;/    S:Envelope&gt;`    log.Println(strings.NewReader(body))    req, err := http.NewRequest(&quot;post&quot;, uri,     bytes.NewBuffer([]byte(body)))    if err != nil {        log.Println(err)        // handle error    }    req.Host = &quot;xxx.com&quot;    resp, err := client.Do(req)    if err != nil {        log.Println(err)    }    log.Println(resp)    //log.Println(respbody)    return err}func main() {    sendmessage(&quot;135xxxxxxx&quot;, &quot;testGolang&quot;)}</code></pre><p>然而我发现此请求并没有获取到短信，于是挂上代理进行抓包，发现其响应码为502.<br><img src="http://ovnsp3bhk.bkt.clouddn.com/Snipaste_2017-09-22_14-08-08.png" alt=""><br>对比Python的正常请求：<br><img src="http://ovnsp3bhk.bkt.clouddn.com/Snipaste_2017-09-22_14-12-11.png" alt=""><br>发现是因为http.NewRequest()方法第一个参数options方法写错了，不能写成小写..</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;详情&quot;&gt;&lt;a href=&quot;#详情&quot; class=&quot;headerlink&quot; title=&quot;详情&quot;&gt;&lt;/a&gt;详情&lt;/h2&gt;&lt;p&gt;昨天由于项目需要，加入发送短信功能，首先测试了一下已存在的一个Python代码，原理比较简单，向一个接口发送一个http post请求，请求的数据为xml格式，同时请求会带一个header头，Key为Host信息。&lt;/p&gt;
&lt;p&gt;Python代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# coding=utf-8

import requests
import cgi

def send(phone, msg):
    url = &amp;apos;http://xxx.com/MoblMsgSender&amp;apos;
    headers = {
        &amp;apos;Host&amp;apos;: &amp;apos;xxx.com&amp;apos;,
    }
    body = &amp;apos;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; ?&amp;gt;&amp;lt;S:Envelope xmlns:S=&amp;quot;http://schemas.xmlsoap.org/soap/envelope/&amp;quot;&amp;gt;&amp;lt;S:Header&amp;gt;&amp;lt;AuthenticationHeader xmlns=&amp;quot;http://xxx.com/MoblMsgSender&amp;quot;&amp;gt;&amp;lt;Token&amp;gt;Tokenxxx==&amp;lt;/Token&amp;gt;&amp;lt;/AuthenticationHeader&amp;gt;&amp;lt;/S:Header&amp;gt;&amp;lt;S:Body&amp;gt;&amp;lt;ns2:xxMmSender xmlns:ns2=&amp;quot;http://xxx.com/&amp;quot;&amp;gt;&amp;lt;arg0 xmlns=&amp;quot;&amp;quot;&amp;gt;%s&amp;lt;/arg0&amp;gt;&amp;lt;arg1 xmlns=&amp;quot;&amp;quot;&amp;gt;%s&amp;lt;/arg1&amp;gt;&amp;lt;arg2 xmlns=&amp;quot;&amp;quot;&amp;gt;yunwei.alarm&amp;lt;/arg2&amp;gt;&amp;lt;arg3 xmlns=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/arg3&amp;gt;&amp;lt;/ns2:xxMmSender&amp;gt;&amp;lt;/S:Body&amp;gt;&amp;lt;/S:Envelope&amp;gt;&amp;apos; % (phone, cgi.escape(msg))
    try:
        r = requests.post(url, data=body, headers=headers)
        if &amp;apos;&amp;lt;return&amp;gt;true&amp;lt;/return&amp;gt;&amp;apos; in r.content:
            return True
    except:
        pass
    return False

send(&amp;quot;135xxxxxxx&amp;quot;,&amp;quot;testPython&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="安全研发" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Xml" scheme="http://yoursite.com/tags/Xml/"/>
    
  </entry>
  
  <entry>
    <title>浅析Android中ZipEntry漏洞</title>
    <link href="http://yoursite.com/2017/09/10/%E6%B5%85%E6%9E%90Android%E4%B8%ADZipEntry%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2017/09/10/浅析Android中ZipEntry漏洞/</id>
    <published>2017-09-10T15:19:30.000Z</published>
    <updated>2017-09-10T16:09:49.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在Android APK加载时，通常情况下会请求各种资源，这其中就包括请求本地或者外部服务器的压缩文件。而由于zip格式压缩文件允许”../“的字符串，攻击者可以在APK加载时对应用本来想加载的文件进行“调虎离山”，将自己利用多个”../“生成的压缩文件替换原文件，这种情况下如果APK对这个zip文件解析不当，那么轻则导致文件覆盖，重则导致本地拒绝服务，甚至代码执行。</p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>这里以一个Apk为例说明，下图中，我反编译了一个APK，获取到了dex文件，利用dex2jar转换成了java中的jar文件并利用Java Decomplier进行读取。<br>定位到存在ZipEntry漏洞的地方，如下图所示：<br><img src="http://ovnsp3bhk.bkt.clouddn.com/a3f3b1d75ac84edea68aa7298461cdc9.png" alt=""><br>可以发现代码的逻辑时调用zipEntry类中的getName()方法，获取到解压到的Zip文件中的自文件名称，但是并未进行任何的../过滤，从而允许了攻击者构造../的zip包进行攻击的可能，攻击者可以构造精心构造的zip包，在root过的手机中抓包，对包含zip的调用包进行篡改，将原zip包篡改成本地构造后的zip包，随后在本地查看文件管理器，可以发现攻击者指定的目录下的文件。<br>构造特定的zip包代码如下：（使用java编写）<br><img src="http://ovnsp3bhk.bkt.clouddn.com/1475713e45644a3283d617c93644fbf1.png" alt=""><br>执行后在zippoc根目录下可发现新生成的test.zip文件<br><img src="http://ovnsp3bhk.bkt.clouddn.com/5754c55d4c344a51aaf154ed0e83239b.png" alt=""><br><img src="http://ovnsp3bhk.bkt.clouddn.com/8f9dbd6785564952b741951744f0507a.png" alt=""><br>上传包中篡改该文件即可。<br>修复方案为在上传包中对文件名进行严格的校验，过滤”../“</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>该漏洞为移动安全漏洞中的低危或中危漏洞，其实不是很好利用，利用方式略微鸡肋但是影响却不小，但很多厂商并未对其进行过多的校验。笔者就发现了滴滴代驾司机客户端、斗鱼Android客户端、Wifi万能钥匙客户端等等均存在此漏洞并进行了报告。<br><img src="http://ovnsp3bhk.bkt.clouddn.com/Snipaste_2017-09-11_00-08-22.png" alt=""><br>该漏洞如果结合了其他漏洞也会产生较为严重的影响，希望厂商予以重视。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在Android APK加载时，通常情况下会请求各种资源，这其中就包括请求本地或者外部服务器的压缩文件。而由于zip格式压缩文件允许”../
      
    
    </summary>
    
      <category term="漏洞研究" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="渗透测试" scheme="http://yoursite.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="ZipEntry" scheme="http://yoursite.com/tags/ZipEntry/"/>
    
  </entry>
  
  <entry>
    <title>伪全栈式安全研发：CVE监控</title>
    <link href="http://yoursite.com/2017/09/02/%E4%BC%AA%E5%85%A8%E6%A0%88%E5%BC%8F%E5%AE%89%E5%85%A8%E7%A0%94%E5%8F%91%EF%BC%9ACVE%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2017/09/02/伪全栈式安全研发：CVE监控/</id>
    <published>2017-09-02T13:57:52.000Z</published>
    <updated>2017-09-25T03:23:05.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>在网络安全圈，攻防是核心，在攻防中漏洞的重要性不言而喻，而CVE是全世界通用漏洞的集合，对于安全人员来说及时知晓刚爆出的通用型漏洞对于企业来讲是十分必要的。本文讲解上周本人在完成CVE监控研发的过程中的一些技术探讨，为什么叫伪全栈呢，因为全栈远不止前端+后端。本例主要使用的技术为Golang、Vuejs、Mongodb、Beego等。</p><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>具体需求为，实时爬取与【公司内部使用的开源框架/组件】相关的业内最新的CVE漏洞，进行网页展示以及报警。</p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>由于Mongodb的灵活性与类Json形式的语法，将其作为我们的数据库。根据需求我们需要两个表，一个表存储CVE关键字和其重要程度；另一个表存储具体爬下来的每一个条CVE详情。<br>关键字表数据格式如下（以两条信息为例）：</p><pre><code>{&quot;_id&quot; : ObjectId(&quot;599d2c1ca9218e4e8ec4e6xx&quot;),&quot;keyword&quot; : [     {        &quot;wordname&quot; : &quot;spring&quot;,        &quot;wordcount&quot; : 1    },     {        &quot;wordname&quot; : &quot;java&quot;,        &quot;wordcount&quot; : 2    }}</code></pre><p>其中wordcount为1表示高危，wordcount为2表示中危。<br>CVE详情表数据格式如下(以一条信息为例)：</p><pre><code>{&quot;_id&quot; : ObjectId(&quot;59a69bf70988ac81605b76xx&quot;),&quot;cve&quot; : &quot;CVE-2017-13758&quot;,&quot;keyword&quot; : &quot;ImageMagick&quot;,&quot;note&quot; : &quot;In ImageMagick 7.0.6-10, there is a heap-based buffer overflow in theTracePoint() function in MagickCore/draw.c.&quot;,&quot;time&quot; : &quot;2017-08-30 19:05:28&quot;,&quot;references&quot; : &quot;CONFIRM:https://www.imagemagick.org/discourse-server/viewtopic.php?f=3&amp;amp;t=32583&quot;,&quot;isignored&quot; : true}</code></pre><p>需要注意的是isignored字段表示是否需要忽略，在安全人员查看信息时，如果认为当前条目CVE不存在严重影响，甚至可以忽略时可以将其置为忽略，而本字段记录其状态。</p><h2 id="爬虫的研发"><a href="#爬虫的研发" class="headerlink" title="爬虫的研发"></a>爬虫的研发</h2><p>我们首先需要找到需要爬取的信息源，一方面需要一个接口能告知我们每日的更新，另一方面我们需要知晓每个CVE编号对应的漏洞详情。通过CVE官网<a href="http://cve.mitre.org/，我们很快找到了两个需要的接口：" target="_blank" rel="external">http://cve.mitre.org/，我们很快找到了两个需要的接口：</a></p><pre><code>https://cassandra.cerias.purdue.edu/CVE_changes/today.html</code></pre><p>以及</p><pre><code>http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-xxxx-xxxx</code></pre><p>姑且称他们为接口1和接口2.爬虫的整体逻辑为向接口1发送请求，正则匹配出我们需要的【New entries】信息，如下图所示<br><img src="http://ovnsp3bhk.bkt.clouddn.com/Snipaste_2017-09-02_23-17-20.png" alt=""><br>然后分别爬取每个cve对应的接口2的url，继续正则匹配出我们想要的漏洞详情信息、相关文档信息等，我们需要的信息如下。<br><img src="http://ovnsp3bhk.bkt.clouddn.com/Snipaste_2017-09-02_23-29-52.png" alt=""><br>随后查keyword库判断是否为我们想要的漏洞，这里比较的是keyword与Description信息，如果是则存到库中。<br>回看整个过程，略微存在技术难点的地方在于正则表达式的编写与golang对Mongodb数据库的操作。<br>请求到的页面源码中，CVE编号的存在形式如下：</p><pre><code>&lt;A HREF = &apos;http://cve.mitre.org/cgi-bin/cvename.cgi?name=2017-3898&apos;&gt;2017-3898&lt;/A&gt;&lt;br /&gt;</code></pre><p>发送请求利用的是grequests库，爬取每日CVE更新信息代码如下：</p><pre><code>func monitorCVEimpl() ([]string) {op := grequests.RequestOptions{    RequestTimeout:     10 * time.Second,    InsecureSkipVerify: true,    RedirectLimit:      5,}urlStr := &quot;https://cassandra.cerias.purdue.edu/CVE_changes/today.html&quot;res, _ := grequests.Get(urlStr, &amp;op)newEntriesStr := Between(res.String(), &quot;New entries:&lt;br /&gt;&quot;, &quot;Graduations (CAN to CVE)&quot;)digitsRegexp := regexp.MustCompile(&quot;&lt;A HREF = &apos;(.*?)&apos;&gt;(.*?)&lt;/A&gt;&quot;)data := digitsRegexp.FindAllStringSubmatch(newEntriesStr, -1)cveStrList := []string{}for _, v := range data {    //fmt.Println(v[2])    if v[2] != &quot;&quot; {        cveStrList = append(cveStrList, v[2])    }}return cveStrList}</code></pre><p>其中Between函数为一个工具函数，获取一个字符串中在字符串2和字符串3中间的子字符串。</p><pre><code>func Between(str, starting, ending string) string {s := strings.Index(str, starting)if s &lt; 0 {    return &quot;&quot;}s += len(starting)e := strings.Index(str[s:], ending)if e &lt; 0 {    return &quot;&quot;}return str[s: s+e]}</code></pre><p><img src="http://ovnsp3bhk.bkt.clouddn.com/Snipaste_2017-09-02_23-49-48.png" alt=""><br>最终返回类似[‘2017-10848’,’2017-10849’]的字符串切片。<br>随后构造为接口2模式的url，同样的方式进行请求，通过工具函数和regexp包，我们能够获取到页面存在的我们需要的信息。随后进行入库操作，Golang操作Mongodb用的是mgo包，基本的增删改查语法可以在<a href="https://studygolang.com/articles/1737查阅到，需要注意的是我们经常会遇到模糊查询的情况，遇到模糊查询时，可以用下面的解决办法：" target="_blank" rel="external">https://studygolang.com/articles/1737查阅到，需要注意的是我们经常会遇到模糊查询的情况，遇到模糊查询时，可以用下面的解决办法：</a></p><pre><code>err := mCVEdb.Find(bson.M{&quot;cve&quot;: bson.M{&quot;$regex&quot;: &quot;CVE-2017&quot;, &quot;$options&quot;: &quot;$i&quot;}}).Distinct(&quot;cve&quot;,&amp;res)</code></pre><p>查询数据库对象mCVEdb对应的数据库中，cve字段模糊匹配CVE-2017字样的文档，并且结果只返回cve集合。<br>根据bson.go官方包中的规定,options参数设置为i是不分大小写的匹配，正好符合我们的需求。<br><img src="http://ovnsp3bhk.bkt.clouddn.com/Snipaste_2017-09-03_00-11-01.png" alt=""><br>至此，我们成功的写完了爬虫脚本并且执行后能把数据存入我们的库中。<br><img src="http://ovnsp3bhk.bkt.clouddn.com/Snipaste_2017-09-03_00-17-38.png" alt=""></p><h2 id="界面的展现"><a href="#界面的展现" class="headerlink" title="界面的展现"></a>界面的展现</h2><p>我们需要一个可视化平台，能够看到我们爬取到的CVE数据。搭建这个平台需要后端接口研发以及前端页面的展现。我们使用的golang http框架为beego，支持RESTful API和MVC模型。<br>后端接口的研发：<br>后端接口，主要是用来查询数据库中的数据并且以json格式返回。<br>在Controller文件中写入</p><pre><code>// @router /cve/ [get]func (c *CveController) GetAll() {var mResultCve = new(models.CveResult)result, err := mResultCve.Cve_search_today()if err != nil {    c.Data[&quot;json&quot;] = utils.AjaxReturn(result, &quot;get message success&quot;, 1)}else {    c.Data[&quot;json&quot;] = utils.AjaxReturn(&quot;&quot;, &quot;Error&quot;, -1)}c.ServeJSON()}</code></pre><p>models层中定义Cve_search_today()函数，将来我们可以在<a href="http://localhost:8080/cve接口获取到返回的json数据以供前端调用。" target="_blank" rel="external">http://localhost:8080/cve接口获取到返回的json数据以供前端调用。</a><br>Cve_search_today()函数模糊查询time字段为当天的数据即可，将[]CVEinfo和err一同返回。<br>前端页面的研发：<br>首先我们需要一个页面url，在Controller中指定：</p><pre><code>//@router /Cve [get]func (this *CveController) GetPage() {this.Data[&quot;title&quot;] = &quot;CVE信息 - &quot;//导航的IDthis.Data[&quot;navCode&quot;] = &quot;opinionNavCode&quot;this.TplName = &quot;cveInfo/index.html&quot;}</code></pre><p>随后编写cveInfo/index.html文件，利用layui+Vuejs进行开发<br>js主要代码</p><pre><code>var vm = new Vue({        delimiters: [&apos;[[&apos;, &apos;]]&apos;],        el: &quot;#body_id&quot;,        data: {            url: &quot;&quot;,            cveList: [],            cveNum: 0,            lasttime: &quot;&quot;,            cveTasktime: &quot;&quot;,            date_range_list: &quot;&quot;            //testList: [&quot;test1&quot;, &quot;test2&quot;, &quot;test3&quot;, &quot;test4&quot;]        },        methods: {            loadData: function (ev) {                var _cveurl = &quot;/cve&quot;                this.cveInfoUrl(_cveurl);                this.cveTaskInfo();            },            initLoad: function () {                var e = {&quot;keyCode&quot;: 13};                this.loadData(e);            },            cveInfoUrl: function (url) {                var me = this;                $.ajax({                    async: true,                    url: url,                    type: &apos;get&apos;,                    datatype: &apos;json&apos;,                    success: function (data) {                        me.buildData(data, me)                    }                });            },            cveTaskInfo: function () {                var me = this;                $.ajax({                    async: true,                    url: &quot;/CveTaskTime&quot;,                    type: &apos;get&apos;,                    datatype: &apos;json&apos;,                    success: function (data) {                        me.lasttime = data.data;                    }                });            },            buildData: function (data, me) {                $(&apos;#cve_id&apos;).html(&quot;&lt;center style=&apos;margin-top:100px&apos;&gt;&lt;a  class=&apos;layui-btn layui-btn-disabled&apos;&gt;数据加载中...&lt;/a&gt;&lt;/center&gt;&quot;);                if (data.status == -1 || data.status == -5) {                    $(&apos;#cve_id&apos;).html(&quot;&lt;center style=&apos;margin-top:100px&apos;&gt;&lt;a  class=&apos;layui-btn layui-btn-disabled&apos;&gt;暂无cve信息&lt;/a&gt;&lt;/center&gt;&quot;);                    return false;                } else {                    $(&apos;#cve_id&apos;).html(&quot;&quot;);                }                var _tmpList = data.data.CveList;                console.log(data.data.CveNum);                this.cveList = []                this.cveNum = data.data.CveNum;                for (var d in _tmpList) {                    if (_tmpList[d].Isignored == false) {                        me.cveList.push({                            &quot;cve&quot;: _tmpList[d].Cve,                            &quot;keyword&quot;: _tmpList[d].Keyword,                            &quot;note&quot;: _tmpList[d].Note,                            &quot;time&quot;: _tmpList[d].Time,                            &quot;reference&quot;: _tmpList[d].References,                            &quot;isignored&quot;: _tmpList[d].Isignored                        });                    }                }                for (var d in _tmpList) {                    if (_tmpList[d].Isignored == true) {                        me.cveList.push({                            &quot;cve&quot;: _tmpList[d].Cve,                            &quot;keyword&quot;: _tmpList[d].Keyword,                            &quot;note&quot;: _tmpList[d].Note,                            &quot;time&quot;: _tmpList[d].Time,                            &quot;reference&quot;: _tmpList[d].References,                            &quot;isignored&quot;: _tmpList[d].Isignored                        });                    }                }                console.log(me.cveList);            },            ignore: function (message) {                $.get(&apos;/cveIgnore/&apos; + message, &apos;&apos;, function (data, status) {                    vm.buildData(data, vm)                })            },            unignore: function (message) {                $.get(&apos;/cveUnIgnore/&apos; + message, &apos;&apos;, function (data, status) {                    vm.buildData(data, vm)                })            }        }    });    //加载事件    window.onload = function () {        vm.initLoad();    };</code></pre><p>html部分主要利用v-for循环和v-if判断来读取ajax请求返回的内容，[[]]双括号可以将vuejs处理后的data数据返回到html页面。<br>页面效果如图：<br><img src="http://ovnsp3bhk.bkt.clouddn.com/Snipaste_2017-09-03_00-43-26.png" alt=""><br>因为让页面更加简洁优美所以未将CVE漏洞详情信息放入页面。</p><h2 id="定时与实时"><a href="#定时与实时" class="headerlink" title="定时与实时"></a>定时与实时</h2><p>要能够定时地完成爬取，我们就需要利用beego的Task任务模块。将开始我们编写的爬虫脚本挂载到beego框架中，然后在脚本最后加入</p><pre><code>func CveRun() {cveSpiderRun := toolbox.NewTask(&quot;cve_spider_run&quot;, &quot;0 0 7 * * *&quot;, CveSpider)toolbox.AddTask(&quot;cve_spider_run&quot;, cveSpiderRun)toolbox.StartTask()defer toolbox.StopTask()}</code></pre><p>需要注意的是toolbox.AddTask第二个参数是脚本启动的入口函数，0 0 7 <em> </em> *为定时任务的时间设定，再此为每日的7点，我们也可以自定义设置，比如每隔10分钟等等，语法与Linux中的Crontab类似。<br>随后在beego Controller层的DefaultController中加入</p><pre><code>func init() {//初始化CVE任务cveTask.CveRun()}</code></pre><p>即可。<br>再此启动项目，访问8088端口(默认)，在Task中可以管理任务。<br><img src="http://ovnsp3bhk.bkt.clouddn.com/Snipaste_2017-09-03_00-51-46.png" alt=""></p><h2 id="邮件预警"><a href="#邮件预警" class="headerlink" title="邮件预警"></a>邮件预警</h2><p>在爬虫文件入库后加入邮件预警函数，内容也较为简单，调用github.com/go-gomail/gomail库发送html邮件，主要代码为先gomail.NewMessage()创建新的Message对象，然后设置邮箱正文、头信息等，使用gomail.NewPlainDialer()配置本端邮箱的账号密码stmp信息，最后DialAndSend()发送即可，注意对异常的处理。邮件正文如下<br><img src="http://ovnsp3bhk.bkt.clouddn.com/Snipaste_2017-09-03_00-54-31.png" alt=""></p><h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><p>本项目仍可提高的点我认为有如下：<br>1.利用Golang并发编程机制加快爬虫速度<br>2.Web界面与邮件界面的UI更加优雅<br>3.多维度漏洞爬虫<br>感谢@Dean、@Mr.Hao、@tanglion在研发过程中对我的帮助与启发。<br>如有错误还请帮指出，感谢阅读。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主题&quot;&gt;&lt;a href=&quot;#主题&quot; class=&quot;headerlink&quot; title=&quot;主题&quot;&gt;&lt;/a&gt;主题&lt;/h2&gt;&lt;p&gt;在网络安全圈，攻防是核心，在攻防中漏洞的重要性不言而喻，而CVE是全世界通用漏洞的集合，对于安全人员来说及时知晓刚爆出的通用型漏洞对于企业来讲是十分必要的。本文讲解上周本人在完成CVE监控研发的过程中的一些技术探讨，为什么叫伪全栈呢，因为全栈远不止前端+后端。本例主要使用的技术为Golang、Vuejs、Mongodb、Beego等。&lt;/p&gt;
    
    </summary>
    
      <category term="安全研发" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E5%8F%91/"/>
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
      <category term="Vuejs" scheme="http://yoursite.com/tags/Vuejs/"/>
    
      <category term="Mongodb" scheme="http://yoursite.com/tags/Mongodb/"/>
    
      <category term="Beego" scheme="http://yoursite.com/tags/Beego/"/>
    
  </entry>
  
  <entry>
    <title>python 基于nmap多线程扫描ms17-010脚本</title>
    <link href="http://yoursite.com/2017/08/26/python-%E5%9F%BA%E4%BA%8Enmap%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%AB%E6%8F%8Fms17-010%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2017/08/26/python-基于nmap多线程扫描ms17-010脚本/</id>
    <published>2017-08-26T11:31:03.000Z</published>
    <updated>2017-09-25T03:13:28.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><p>nmap 7.50及以后的版本支持对MS17-010漏洞，即永恒之蓝漏洞的扫描，以下为针对甲方公司的安全人员，针对公司内网网段进行批量的多线程漏洞扫描。</p><p>脚本的原理为首先生成一个带扫描的ip文件，然后调用nmap命令nmap -iL ip_test.txt -p 445 –open -T4 -oX ./result/filename.txt来扫描开放了445端口的ip，并生成列表，随后读取445端口开放的ip并放入队列中，然后多线程处理队列中的ip并利用nmap命令nmap -p 445 –script smb-vuln-ms17-010.nse IP来检测存在漏洞的ip数量。</p><a id="more"></a><p>nmap 7.50及以后的版本支持对MS17-010漏洞，即永恒之蓝漏洞的扫描，以下为针对甲方公司的安全人员，针对公司内网网段进行批量的多线程漏洞扫描。</p><p>脚本的原理为首先生成一个带扫描的ip文件，然后调用nmap命令nmap -iL ip_test.txt -p 445 –open -T4 -oX ./result/filename.txt来扫描开放了445端口的ip，并生成列表，随后读取445端口开放的ip并放入队列中，然后多线程处理队列中的ip并利用nmap命令nmap -p 445 –script smb-vuln-ms17-010.nse IP来检测存在漏洞的ip数量。</p><pre><code>#!/usr//bin/python# -*- coding: utf-8 -*-# author: bipabo1l@csoio.comimport osimport requestsimport timeimport reimport commandslist_vul_ip = []class WyWorker(threading.Thread):    def __init__(self, queue):        threading.Thread.__init__(self)        self.queue = queue    def run(self):        while True:            if self.queue.empty():                break            try:                ip = self.queue.get_nowait()                if ip:                    (status, output) = commands.getstatusoutput(&apos;nmap -p 445 --script smb-vuln-ms17-010.nse &apos; + ip)                    print output                    if &apos;CVE&apos; in output:                        list_vul_ip.append(ip)            except Exception, e:                break        print &quot;scan success&quot;def main():    try:        threads_count = 10        queue = Queue.Queue()        print &quot;begin:&quot;        files = &apos;445_open:&apos; + str(int(time.time()))        print &quot;scaning:&quot;        os.system(&apos;nmap -iL ip_test.txt -p 445 --open -T4 -oX ./result/%s.txt&apos; % files)        print &quot;scansuccess&quot;        file_name = files + &apos;.txt&apos;        file = open(&apos;/root/619/445/result/%s&apos; % file_name)        f_result = file.read()        regex = &apos;addr(.*)addrtype&apos;        list_ip = []        for m in re.findall(regex, f_result):            list_ip.append(m[10:-2])        print &quot;445 port open mechines:&quot;         print list_ip        for ip in list_ip:            queue.put(ip)        print queue.qsize()        # 初始化线程组        threads = []        for i in xrange(threads_count):            threads.append(WyWorker(queue))        # 启动线程        for t in threads:            t.start()        # 等待线程执行结束后，回到主线程中        for t in threads:            t.join()        print list_vul_ip    except:        passif __name__ == &apos;__main__&apos;:    main()</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;详情&quot;&gt;&lt;a href=&quot;#详情&quot; class=&quot;headerlink&quot; title=&quot;详情&quot;&gt;&lt;/a&gt;详情&lt;/h2&gt;&lt;p&gt;nmap 7.50及以后的版本支持对MS17-010漏洞，即永恒之蓝漏洞的扫描，以下为针对甲方公司的安全人员，针对公司内网网段进行批量的多线程漏洞扫描。&lt;/p&gt;
&lt;p&gt;脚本的原理为首先生成一个带扫描的ip文件，然后调用nmap命令nmap -iL ip_test.txt -p 445 –open -T4 -oX ./result/filename.txt来扫描开放了445端口的ip，并生成列表，随后读取445端口开放的ip并放入队列中，然后多线程处理队列中的ip并利用nmap命令nmap -p 445 –script smb-vuln-ms17-010.nse IP来检测存在漏洞的ip数量。&lt;/p&gt;
    
    </summary>
    
      <category term="安全研发" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E5%8F%91/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="MS17-010" scheme="http://yoursite.com/tags/MS17-010/"/>
    
      <category term="wannaCry" scheme="http://yoursite.com/tags/wannaCry/"/>
    
  </entry>
  
  <entry>
    <title>whatweb入库乱码问题详解</title>
    <link href="http://yoursite.com/2017/08/21/whatweb%E5%85%A5%E5%BA%93%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/08/21/whatweb入库乱码问题详解/</id>
    <published>2017-08-21T08:24:23.000Z</published>
    <updated>2017-09-25T03:26:46.429Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解笔者在使用whatweb对域名库中的域名进行指纹爬取并入库mongodb时遇到的一些坑以及解决方案。</p><h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>通过whatweb扫描出来的数据，插入到数据库中后，发现很多不同的编码和乱码，包括url编码、unicode编码、乱码等等，如下</p><a id="more"></a><p><img src="http://i.imgur.com/U3VSDzA.jpg" alt=""></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>当我直接在命令行执行几个数据库中Title字段乱码或者编码有问题的Domain时，命令行直接输出的Title是正常的中文汉字<br><img src="http://i.imgur.com/exLX3nS.jpg" alt=""><br>所以判断是代码的问题，进入到代码中，发现原来的代码whatweb扫描出来之后，未特殊判断可能带有汉字的Title，于是加上了一个单独的Title判断，如果是Title，那么Append到list之前经过一个函数处理，<br>函数判断是否为unicode（基本全部是unicode），如果是先url解码（因为当前的数据类型是）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">u&apos;JIMI%E6%99%BA%E8%83%BD%E6%9C%BA%E5%99%A8%E4%BA%BA - %E4%BA%AC%E4%B8%9C&apos;</div></pre></td></tr></table></figure></p><!--more--><p>想到把<br><img src="http://i.imgur.com/c7Zwvb8.png" alt=""><br>这段代码直接unicode转汉字应该就能解决问题了，于是加上</p><pre><code>.decode(&apos;unicode-escape&apos;)</code></pre><p>发现直接输出为乱码，return后输出的并未unicode解密，反而二次unicode加密</p><p>于是思考从url解码之前就处理问题，而不是经过解码之后变成unicode再处理。发现在main函数中，最后输出时还有json.dumps处理，那么直接打印处理前的数据，看中文是如何显示的<br><img src="http://i.imgur.com/47SAyJB.png" alt=""><br>发现是控制台信息输出窗口按照ascii编码输出utf8编码的字符串的结果，这时候基本可以定位问题了，是在转换到json格式时出现的问题，json.dumps函数中加一个ensure_ascii参数，值设置为False即可。测试一下：<br><img src="http://i.imgur.com/qOemh19.png" alt=""><br>显示成功！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以最后的解决方案为：<br>1.jdradar\core\fingerprint路径下的WhatWeb.py，parse_plugin函数中判断一下name是否为Title，如果是，将plugin.get(‘string’)处理成字符串模式后，plugins.append({name: deal_word_method(string)})plugins列表添加时string用deal_word_method函数处理，函数判断传入的word是否为unicode，是的话url解码。<br>然后返回<br><img src="http://i.imgur.com/2y69CFG.png" alt=""><br>2.在jdradar\tasks.py的fingerprint_scan函数中，加入json.dumps处理，ensure_ascii设置为False</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试是否有效：<br>选取一个原来差入后Title乱码的document，domain为<a href="http://jimi-api.jd.com:80" target="_blank" rel="external">http://jimi-api.jd.com:80</a><br><img src="http://i.imgur.com/emPA8cm.png" alt=""><br>利用如下代码，进行插入<br><img src="http://i.imgur.com/kih39mN.png" alt=""><br>插入成功后，查看DocumentTitle字段是否乱码<br><img src="http://i.imgur.com/iJJO6Pi.png" alt=""><br>执行成功，未乱码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲解笔者在使用whatweb对域名库中的域名进行指纹爬取并入库mongodb时遇到的一些坑以及解决方案。&lt;/p&gt;
&lt;h2 id=&quot;详情&quot;&gt;&lt;a href=&quot;#详情&quot; class=&quot;headerlink&quot; title=&quot;详情&quot;&gt;&lt;/a&gt;详情&lt;/h2&gt;&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;通过whatweb扫描出来的数据，插入到数据库中后，发现很多不同的编码和乱码，包括url编码、unicode编码、乱码等等，如下&lt;/p&gt;
    
    </summary>
    
      <category term="安全研发" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E5%8F%91/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/08/21/hello-world/"/>
    <id>http://yoursite.com/2017/08/21/hello-world/</id>
    <published>2017-08-21T06:34:13.131Z</published>
    <updated>2017-08-21T06:34:13.132Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
